package cli

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
	"repoctr/internal/config"
	"repoctr/internal/detector"
	"repoctr/internal/discovery"
	"repoctr/pkg/models"
)

// NewIdentifyCmd creates the identify command.
func NewIdentifyCmd() *cobra.Command {
	var outputFile string

	cmd := &cobra.Command{
		Use:   "identify [paths...]",
		Short: "Discover projects in the specified paths",
		Long: `Recursively scans the specified directories to discover projects.
Detects projects based on manifest files (go.mod, package.json, etc.).
Builds a hierarchical project tree and outputs to projects.yaml.`,
		Args: cobra.MinimumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			return RunIdentify(args, outputFile)
		},
	}

	cmd.Flags().StringVarP(&outputFile, "output", "o", projectsFileName, "Output file path")

	return cmd
}

// RunIdentify discovers projects in the given paths and writes to outputFile.
func RunIdentify(paths []string, outputFile string) error {
	registry := detector.NewRegistry()
	builder := discovery.NewHierarchyBuilder()

	var allProjects []*models.Project

	// Process each input path
	for _, path := range paths {
		absPath, err := filepath.Abs(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: invalid path %s: %v\n", path, err)
			continue
		}

		// Check if path exists
		info, err := os.Stat(absPath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: cannot access %s: %v\n", path, err)
			continue
		}

		if !info.IsDir() {
			fmt.Fprintf(os.Stderr, "Warning: %s is not a directory, skipping\n", path)
			continue
		}

		fmt.Printf("Scanning %s...\n", absPath)

		walker, err := discovery.NewWalker(absPath, registry)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: failed to create walker for %s: %v\n", path, err)
			continue
		}

		projects, err := walker.Discover()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: discovery failed for %s: %v\n", path, err)
			continue
		}

		allProjects = append(allProjects, projects...)
		fmt.Printf("  Found %d project(s)\n", len(projects))
	}

	if len(allProjects) == 0 {
		fmt.Println("No projects discovered.")
		return nil
	}

	// Build hierarchy
	hierarchy := builder.Build(allProjects)

	// Get root directory from output file location
	rootDir := filepath.Dir(outputFile)
	if rootDir == "" || rootDir == "." {
		rootDir, _ = filepath.Abs(".")
	} else {
		rootDir, _ = filepath.Abs(rootDir)
	}

	// Load existing projects if they exist
	var existingProjects []*models.Project
	if existingData, err := os.ReadFile(outputFile); err == nil {
		var existingConfig models.ProjectsConfig
		if err := yaml.Unmarshal(existingData, &existingConfig); err == nil {
			existingProjects = existingConfig.Projects
		}
	}

	// Load configuration
	cfg, err := config.LoadConfig(rootDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: failed to load config: %v\n", err)
		cfg = &models.RepoCtrConfig{}
	}

	// Merge projects (non-destructive)
	mergedProjects := config.MergeProjects(hierarchy, existingProjects, cfg)

	// Create config
	projectsConfig := models.ProjectsConfig{
		Projects: mergedProjects,
	}

	// Marshal to YAML
	data, err := yaml.Marshal(projectsConfig)
	if err != nil {
		return fmt.Errorf("failed to marshal projects: %w", err)
	}

	// Add header comment
	header := fmt.Sprintf(`# projects.yaml - Repository project configuration
# Generated by repo-ctr identify
# Total projects discovered: %d

`, countProjects(mergedProjects))
	content := header + string(data)

	// Write file
	if err := os.WriteFile(outputFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write %s: %w", outputFile, err)
	}

	absOutput, _ := filepath.Abs(outputFile)
	fmt.Printf("\nWrote %d project(s) to %s\n", countProjects(mergedProjects), absOutput)
	printProjectSummary(mergedProjects, 0)

	return nil
}

func countProjects(projects []*models.Project) int {
	count := len(projects)
	for _, p := range projects {
		count += countProjects(p.Children)
	}
	return count
}

func printProjectSummary(projects []*models.Project, depth int) {
	indent := ""
	for i := 0; i < depth; i++ {
		indent += "  "
	}

	for _, p := range projects {
		version := ""
		if p.Runtime.Version != "" {
			version = " " + p.Runtime.Version
		}
		fmt.Printf("%s  - %s (%s%s)\n", indent, p.Name, p.Runtime.Type, version)
		printProjectSummary(p.Children, depth+1)
	}
}
